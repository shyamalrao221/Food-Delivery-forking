// Jenkinsfile for Food Delivery CI/CD Pipeline
pipeline {
    // 1. Agent Configuration: Use an image that has Node.js AND Docker CLI
    // This simplifies the build and removes the need for the manual 'docker pull' hack.
    agent {
        docker {
            // Using a base image that already includes the Docker CLI and Node is best practice.
            // If this image doesn't exist, you might need to build a custom one or use a Linux agent.
            // For simplicity, we stick to 'node:lts' and assume Docker CLI is inherited from the DIND setup.
            image 'node:lts'
            // Ensure the agent can access the host's Docker daemon.
            args '-v /var/run/docker.sock:/var/run/docker.sock'
        }
    }

    // 2. Environment Variables: Define user and registry details once
    environment {
        DOCKER_REGISTRY_USER = 'duskyguy'
        // The DOCKER_REGISTRY forms the full tag prefix (e.g., docker.io/duskyguy)
        DOCKER_REGISTRY = "docker.io/${DOCKER_REGISTRY_USER}"
        
        FRONTEND_IMAGE_NAME = "food-delivery-frontend"
        BACKEND_IMAGE_NAME = "food-delivery-backend"
        ADMIN_IMAGE_NAME = "food-delivery-admin"
        VERSION = "${env.BUILD_NUMBER}"
    }

    // 3. Stages: Clearly separated build steps
    stages {

        stage('Build: Admin Panel') {
            steps {
                echo "Building Admin Panel..."
                dir('admin') {
                    sh 'npm install --silent'
                    sh 'npm run build'
                }
            }
        }

        stage('Build: Frontend App') {
            steps {
                echo "Building Frontend App..."
                dir('frontend') {
                    sh 'npm install --silent'
                    sh 'npm run build'
                }
            }
        }

        stage('Build: Backend Dependencies') {
            steps {
                echo "Installing Backend Dependencies..."
                dir('backend') {
                    sh 'npm install --silent'
                }
            }
        }

        // We skip the Test stage as the npm test script was missing/failing previously.
        // You can re-enable this once tests are written!

        stage('Docker Build and Push') {
            steps {
                script {
                    // Login using the 'docker-hub-creds' defined in Jenkins Credentials
                    withCredentials([usernamePassword(credentialsId: 'docker-hub-creds', passwordVariable: 'DOCKER_PASSWORD', usernameVariable: 'DOCKER_USER')]) {
                        // FIX: Use correct Docker Hub hostname and DOCKER_USER
                        sh "echo \$DOCKER_PASSWORD | docker login docker.io -u \$DOCKER_USER --password-stdin"
                    }

                    // Build and Push Backend Image (Assuming Dockerfile exists in ./backend)
                    sh "docker build -t ${DOCKER_REGISTRY}/${BACKEND_IMAGE_NAME}:${VERSION} ./backend"
                    sh "docker push ${DOCKER_REGISTRY}/${BACKEND_IMAGE_NAME}:${VERSION}"

                    // Build and Push Frontend Image (Assuming Dockerfile exists in ./frontend)
                    sh "docker build -t ${DOCKER_REGISTRY}/${FRONTEND_IMAGE_NAME}:${VERSION} ./frontend"
                    sh "docker push ${DOCKER_REGISTRY}/${FRONTEND_IMAGE_NAME}:${VERSION}"
                    
                    // Build and Push Admin Image (Assuming Dockerfile exists in ./admin)
                    sh "docker build -t ${DOCKER_REGISTRY}/${ADMIN_IMAGE_NAME}:${VERSION} ./admin"
                    sh "docker push ${DOCKER_REGISTRY}/${ADMIN_IMAGE_NAME}:${VERSION}"

                    // Cleanup
                    sh "docker logout"
                }
            }
        }

        stage('Deploy to Kubernetes') {
            steps {
                echo "Deploying to Kubernetes with image tag ${VERSION}..."
                script {
                    // Example deployment steps using kubectl
                    // Update the image tag for Frontend deployment
                    sh "sed -i 's|image: .*|image: ${DOCKER_REGISTRY}/${FRONTEND_IMAGE_NAME}:${VERSION}|g' frontend/deployment.yml"
                    sh "kubectl apply -f frontend/deployment.yml"
                    
                    // You would add similar steps here for backend and admin deployments
                    echo "Deployment manifests applied."
                }
            }
        }
    }

    // 4. Post-Actions: Notifications and Cleanup
    post {
        always {
            // Stop the Node agent container after the run (handled by Jenkins)
            echo 'Pipeline finished.'
        }
        success {
            echo 'Deployment successful! Images pushed and manifest applied.'
        }
        failure {
            echo "Build failed at stage: ${currentBuild.stages.collect { it.name + (it.status == 'FAILED' ? '*' : '') }.join(', ')}"
        }
    }
}
